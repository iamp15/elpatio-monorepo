"use strict";

const BOT_CONFIG = require("../../config/bot-config");
const userStateManager = require("../../user-state");
const { registerOrFindPlayer } = require("../../utils/helpers");
const abandonLimitManager = require("../../utils/abandon-limits");

// Variables de entorno
const TEST_MODE = process.env.TEST_MODE === "true" || !process.env.BACKEND_URL;

/**
 * Maneja la selecci√≥n de modo para crear sala
 */
async function handleCreateSalaMode(bot, api, callbackQuery, modo) {
  const { message, from } = callbackQuery;
  const chatId = message.chat.id;
  const userId = from.id;

  try {
    // Obtener el juego seleccionado
    const selectedGame = userStateManager.getSelectedGame(userId);
    if (!selectedGame) {
      await bot.answerCallbackQuery(callbackQuery.id, {
        text: "Primero selecciona un juego.",
      });
      return;
    }

    const juego = BOT_CONFIG.juegos.find((j) => j.id === selectedGame);
    if (!juego) {
      await bot.answerCallbackQuery(callbackQuery.id, {
        text: "Juego no encontrado.",
      });
      return;
    }

    // Guardar el modo seleccionado en el estado del usuario
    userStateManager.setState(userId, {
      ...userStateManager.getState(userId),
      creatingSala: {
        modo,
        juego: selectedGame,
      },
    });

    // Acknowledge callback
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: `Modo seleccionado: ${juego.modos[modo]?.nombre || modo}`,
    });

    // Solicitar nombre de la sala
    await bot.sendMessage(
      chatId,
      `üìù <b>Nombre de la Sala</b>

Escribe el nombre para tu sala de ${juego.nombre} (${
        juego.modos[modo]?.nombre || modo
      }):

üí° <b>Sugerencias:</b>
‚Ä¢ Sala de ${from.first_name}
‚Ä¢ ${juego.nombre} ${modo}
‚Ä¢ Mi ${juego.nombre} favorito

üìù Env√≠a el nombre de la sala:`,
      { parse_mode: "HTML" }
    );
  } catch (err) {
    console.error("‚ùå Error en selecci√≥n de modo:", err.message);
    await bot.answerCallbackQuery(callbackQuery.id, { text: "‚ùå Error" });
    await bot.sendMessage(
      chatId,
      "‚ùå Error procesando selecci√≥n. Intenta de nuevo."
    );
  }
}

/**
 * Maneja el proceso de unirse a una sala
 */
async function handleJoinSala(bot, api, callbackQuery, salaId) {
  const { message, from } = callbackQuery;
  const chatId = message.chat.id;

  try {
    // 1) Buscar o crear jugador en backend (por telegramId)
    const jugador = await registerOrFindPlayer(api, from);

    // 2) Obtener informaci√≥n de la sala para verificar el precio de entrada
    const salas = await api.getSalasDisponibles();
    const sala = salas.find((s) => s._id === salaId);

    if (!sala) {
      await bot.answerCallbackQuery(callbackQuery.id, {
        text: "‚ùå Sala no encontrada",
      });
      await bot.sendMessage(
        chatId,
        "‚ùå <b>Error:</b> La sala no fue encontrada. Intenta de nuevo.",
        { parse_mode: "HTML" }
      );
      return;
    }

    const precioEntrada = sala.configuracion?.entrada || 0;

    // 3) Verificar saldo del jugador
    const saldoJugador = await api.getPlayerBalance(from.id.toString());

    if (saldoJugador < precioEntrada) {
      // Saldo insuficiente - mostrar mensaje y bot√≥n de dep√≥sito
      const inlineKeyboard = {
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: "üí∞ Hacer Dep√≥sito",
                callback_data: "deposito:inicio",
              },
            ],
            [
              {
                text: "‚ùå Cancelar",
                callback_data: "cancelar:entrada",
              },
            ],
          ],
        },
      };

      await bot.sendMessage(
        chatId,
        `‚ùå <b>Saldo insuficiente</b>
          üí∞ <b>Tu saldo:</b> ${(saldoJugador / 100).toLocaleString("es-VE")} Bs
          üéÆ <b>Precio de entrada:</b> ${(precioEntrada / 100).toLocaleString(
            "es-VE"
          )} Bs üéØ <b>Sala:</b> ${sala.nombre || sala._id}
          üí° <b>Para unirte a esta sala necesitas m√°s saldo.</b>
          ¬øDeseas hacer un dep√≥sito?`,
        { parse_mode: "HTML", ...inlineKeyboard }
      );

      await bot.answerCallbackQuery(callbackQuery.id, {
        text: "‚ùå Saldo insuficiente",
      });
      return;
    }

    // 4) Enviar mensaje de confirmaci√≥n antes de debitar
    const confirmKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: "‚úÖ Confirmar entrada",
              callback_data: `confirmar_entrada:${salaId}`,
            },
            {
              text: "‚ùå Cancelar",
              callback_data: "cancelar:entrada",
            },
          ],
        ],
      },
    };

    await bot.sendMessage(
      chatId,
      `‚ö†Ô∏è <b>Confirmaci√≥n de entrada</b>

üéÆ <b>Sala:</b> ${sala.nombre || sala._id}
üí∞ <b>Precio de entrada:</b> ${(precioEntrada / 100).toLocaleString("es-VE")} Bs
üí≥ <b>Tu saldo actual:</b> ${(saldoJugador / 100).toLocaleString("es-VE")} Bs
üí∏ <b>Saldo despu√©s del pago:</b> ${(
        (saldoJugador - precioEntrada) /
        100
      ).toLocaleString("es-VE")} Bs

‚ö†Ô∏è <b>Se te descontar√° el precio de entrada de tu saldo.</b>

¬øConfirmas que deseas unirte a la sala?`,
      { parse_mode: "HTML", ...confirmKeyboard }
    );

    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "‚è≥ Confirmando entrada...",
    });
  } catch (err) {
    console.error("‚ùå Error en join sala:", err.response?.data || err.message);

    // Manejar errores espec√≠ficos del backend
    const errorData = err.response?.data || err.message;
    if (errorData && typeof errorData === "object" && errorData.mensaje) {
      const mensaje = errorData.mensaje;

      // Errores espec√≠ficos de validaci√≥n
      if (
        mensaje.includes(
          "No puedes unirte a una sala mientras est√°s jugando"
        ) ||
        (mensaje.includes("est√°s jugando") && mensaje.includes("unirte"))
      ) {
        await bot.sendMessage(
          chatId,
          `‚ùå <b>No puedes unirte a una sala mientras est√°s jugando</b>
            üéÆ <b>Estado actual:</b> Jugando üë§ <b>Jugador:</b> ${
              from.first_name || from.username || "Jugador"
            }
            üí° <b>Soluci√≥n:</b>‚Ä¢ Termina tu partida actual ‚Ä¢ O espera a que
            termine autom√°ticamente ‚Ä¢ Luego podr√°s unirte a una sala`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, {
          text: "Est√°s jugando, no puedes unirte",
        });
      } else if (mensaje.includes("Ya est√°s en la sala")) {
        await bot.sendMessage(
          chatId,
          `‚ÑπÔ∏è <b>Ya te encuentras en esta sala</b>

No puedes unirte dos veces a la misma sala.`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, {
          text: "Ya est√°s en la sala",
        });
      } else if (
        mensaje.includes("Ya est√°s participando en una sala de modo")
      ) {
        await bot.sendMessage(
          chatId,
          `‚ùå <b>L√≠mite de participaci√≥n alcanzado</b>

${mensaje}

üí° <b>Soluci√≥n:</b> Debes salir de la sala actual antes de unirte a otra del mismo modo.`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, {
          text: "L√≠mite de modo alcanzado",
        });
      } else if (mensaje.includes("Ya est√°s participando en 2 salas")) {
        await bot.sendMessage(
          chatId,
          `‚ùå <b>L√≠mite de participaci√≥n alcanzado</b>

${mensaje}

üí° <b>Soluci√≥n:</b> Debes salir de una sala antes de unirte a otra.`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, {
          text: "L√≠mite de salas alcanzado",
        });
      } else if (mensaje.includes("La sala est√° llena")) {
        await bot.sendMessage(
          chatId,
          `‚ùå <b>Sala llena</b>

Esta sala ya no tiene espacio disponible. Busca otra sala o crea una nueva.`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, {
          text: "Sala llena",
        });
      } else if (
        mensaje.includes("Ya hay 5 salas de") &&
        mensaje.includes("esperando jugadores")
      ) {
        await bot.sendMessage(
          chatId,
          `‚ùå <b>L√≠mite de salas alcanzado</b>

${mensaje}

üí° <b>Soluci√≥n:</b> Intenta crear una sala de otro modo o espera a que se complete una sala existente.`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, {
          text: "L√≠mite de salas alcanzado",
        });
      } else {
        // Otros errores espec√≠ficos del backend
        await bot.sendMessage(
          chatId,
          `‚ùå <b>Error al unirse</b>

${mensaje}`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, { text: "‚ùå Error" });
      }
    } else {
      // Error gen√©rico
      await bot.sendMessage(
        chatId,
        "‚ùå Error uni√©ndote a la sala. Intenta de nuevo o contacta al admin."
      );
      await bot.answerCallbackQuery(callbackQuery.id, { text: "‚ùå Error" });
    }
  }
}

/**
 * Maneja la confirmaci√≥n para abandonar una sala
 */
async function handleConfirmLeaveSala(bot, api, callbackQuery, salaId) {
  const { message, from } = callbackQuery;
  const chatId = message.chat.id;

  try {
    // Obtener informaci√≥n de la sala para mostrar en la confirmaci√≥n
    let salaInfo = { nombre: `Sala ${salaId.slice(-6)}`, _id: salaId };

    // Usar el nuevo endpoint para obtener informaci√≥n espec√≠fica de la sala
    if (!process.env.TEST_MODE && process.env.BACKEND_URL) {
      try {
        console.log(`üîç Intentando obtener informaci√≥n de sala: ${salaId}`);

        // Usar el nuevo endpoint GET api/salas/:salaId
        const sala = await api.getSalaById(salaId);

        console.log(
          `üìä Respuesta del endpoint:`,
          JSON.stringify(sala, null, 2)
        );

        if (sala && sala.nombre) {
          console.log(`‚úÖ Sala encontrada con nombre: ${sala.nombre}`);
          salaInfo = sala;
        } else if (sala) {
          // Si la sala existe pero no tiene nombre, usar un nombre m√°s descriptivo
          console.log(`‚ö†Ô∏è Sala encontrada sin nombre, usando fallback`);
          salaInfo.nombre = `Sala ${sala._id.slice(-6)}`;
        } else {
          console.log(`‚ùå Sala no encontrada en el endpoint`);
        }
      } catch (err) {
        console.log(
          "‚ùå Error obteniendo info de sala para confirmaci√≥n:",
          err.message
        );
        console.log("üìã Stack trace:", err.stack);
        // Mantener el nombre por defecto con ID parcial
      }
    } else {
      console.log(`üîß TEST_MODE o BACKEND_URL no configurado:`, {
        TEST_MODE: process.env.TEST_MODE,
        BACKEND_URL: process.env.BACKEND_URL,
      });

      // En modo de prueba, intentar obtener informaci√≥n de las salas disponibles
      if (api) {
        try {
          console.log(`üîç Modo de prueba: buscando sala en salas disponibles`);
          const salas = await api.getSalasDisponibles();
          const sala = salas.find((s) => s._id === salaId);

          if (sala && sala.nombre) {
            console.log(`‚úÖ Sala encontrada en modo de prueba: ${sala.nombre}`);
            salaInfo = sala;
          } else if (sala) {
            console.log(`‚ö†Ô∏è Sala encontrada sin nombre en modo de prueba`);
            salaInfo.nombre = `Sala ${sala._id.slice(-6)}`;
          }
        } catch (err) {
          console.log(`‚ùå Error en modo de prueba: ${err.message}`);
        }
      }
    }

    // Crear botones de confirmaci√≥n
    const inlineKeyboard = {
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: "‚úÖ S√≠, abandonar",
              callback_data: `leave:${salaId}`,
            },
            {
              text: "‚ùå Cancelar",
              callback_data: `cancel_leave:${salaId}`,
            },
          ],
        ],
      },
    };

    // Obtener informaci√≥n de l√≠mites de abandonos del jugador
    const abandonLimits = abandonLimitManager.getPlayerStats(from.id);
    let mensajeConfirmacion = "";

    if (abandonLimits) {
      const abandonosRestantesHora = 3 - abandonLimits.abandonosHora;

      if (abandonosRestantesHora > 1) {
        // Mensaje normal para m√∫ltiples abandonos restantes
        mensajeConfirmacion = `‚ö†Ô∏è <b>¬øEst√°s seguro de que quieres abandonar la sala?</b>

üéÆ <b>Sala:</b> ${salaInfo.nombre || salaInfo._id}
üë§ <b>Usuario:</b> ${from.first_name || from.username || "Jugador"}

‚ö†Ô∏è <b>Recuerda:</b> Solo puedes abandonar ${abandonosRestantesHora} veces m√°s en la pr√≥xima hora.

<b>¬øDeseas continuar?</b>`;
      } else if (abandonosRestantesHora === 1) {
        // Mensaje de advertencia para √∫ltimo abandono
        mensajeConfirmacion = `‚ö†Ô∏è <b>¬øEst√°s seguro de que quieres abandonar la sala?</b>

üéÆ <b>Sala:</b> ${salaInfo.nombre || salaInfo._id}
üë§ <b>Usuario:</b> ${from.first_name || from.username || "Jugador"}

üö® <b>¬°CUIDADO!</b> Solo puedes abandonar 1 vez m√°s antes de ser bloqueado.

<b>¬øDeseas continuar?</b>`;
      } else {
        // Mensaje cuando ya no puede abandonar (aunque no deber√≠a llegar aqu√≠)
        mensajeConfirmacion = `‚ö†Ô∏è <b>¬øEst√°s seguro de que quieres abandonar la sala?</b>

üéÆ <b>Sala:</b> ${salaInfo.nombre || salaInfo._id}
üë§ <b>Usuario:</b> ${from.first_name || from.username || "Jugador"}

‚ùå <b>No puedes abandonar m√°s salas en este momento.</b>

<b>¬øDeseas continuar?</b>`;
      }
    } else {
      // Mensaje para jugador sin historial
      mensajeConfirmacion = `‚ö†Ô∏è <b>¬øEst√°s seguro de que quieres abandonar la sala?</b>

üéÆ <b>Sala:</b> ${salaInfo.nombre || salaInfo._id}
üë§ <b>Usuario:</b> ${from.first_name || from.username || "Jugador"}

‚ö†Ô∏è <b>Recuerda:</b> Solo puedes abandonar 3 veces en la pr√≥xima hora.

<b>¬øDeseas continuar?</b>`;
    }

    // Mensaje de confirmaci√≥n
    await bot.sendMessage(chatId, mensajeConfirmacion, {
      parse_mode: "HTML",
      ...inlineKeyboard,
    });

    // Acknowledge callback
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "Confirmando abandono...",
    });
  } catch (err) {
    console.error("‚ùå Error en confirmaci√≥n de abandono:", err.message);
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "‚ùå Error en confirmaci√≥n",
    });
    await bot.sendMessage(
      chatId,
      "‚ùå Error procesando la confirmaci√≥n. Intenta de nuevo."
    );
  }
}

/**
 * Maneja la cancelaci√≥n del abandono de sala
 */
async function handleCancelLeaveSala(bot, api, callbackQuery, salaId) {
  const { message, from } = callbackQuery;
  const chatId = message.chat.id;

  try {
    // Acknowledge callback
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "‚ùå Abandono cancelado",
    });

    // Mensaje de cancelaci√≥n
    await bot.sendMessage(
      chatId,
      `‚úÖ <b>Abandono cancelado</b>

Has decidido permanecer en la sala. ¬°Disfruta tu partida!`,
      { parse_mode: "HTML" }
    );
  } catch (err) {
    console.error("‚ùå Error cancelando abandono:", err.message);
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "‚ùå Error",
    });
  }
}

/**
 * Maneja el proceso de abandonar una sala
 * El backend ahora maneja autom√°ticamente el reembolso
 */
async function handleLeaveSala(bot, api, callbackQuery, salaId) {
  const { message, from } = callbackQuery;
  const chatId = message.chat.id;
  const telegramId = from.id;

  try {
    // 0) Verificar si el jugador puede abandonar (sistema de l√≠mites)
    console.log(
      `üîç [LEAVESALA] Verificando permisos para usuario: ${telegramId}`
    );
    console.log(
      `üìä [LEAVESALA] Cache antes de verificar:`,
      abandonLimitManager.cache.size,
      "usuarios"
    );

    const permisoAbandono = abandonLimitManager.canAbandon(telegramId);

    console.log(
      `üìä [LEAVESALA] Resultado de canAbandon:`,
      JSON.stringify(permisoAbandono, null, 2)
    );
    console.log(
      `üìä [LEAVESALA] Cache despu√©s de verificar:`,
      abandonLimitManager.cache.size,
      "usuarios"
    );

    if (!permisoAbandono.canAbandon) {
      await bot.answerCallbackQuery(callbackQuery.id, {
        text: "‚ùå No puedes abandonar temporalmente",
        show_alert: true,
      });

      await bot.sendMessage(chatId, permisoAbandono.mensaje, {
        parse_mode: "HTML",
      });
      return;
    }

    // 1) Buscar o crear jugador en backend (por telegramId)
    const jugador = await registerOrFindPlayer(api, from);

    // 2) Llamar al endpoint que ahora maneja reembolso autom√°ticamente
    const leaveRes = await api.eliminarJugadorDeSala(
      salaId,
      jugador._id || jugador.id
    );

    const sala = leaveRes.sala || leaveRes;
    const salaCancelada = leaveRes.cancelada || false;
    const reembolsoInfo = leaveRes.reembolso || null; // Informaci√≥n del backend

    console.log(`‚úÖ Jugador ${jugador._id} eliminado de sala ${salaId}`);
    if (reembolsoInfo) {
      console.log(
        `üí∞ Reembolso ${reembolsoInfo.procesado ? "exitoso" : "fall√≥"}: ${
          reembolsoInfo.referencia || reembolsoInfo.error
        }`
      );
    }

    // 3) Responder al jugador seg√∫n si la sala fue cancelada o no
    if (salaCancelada) {
      let mensajeCancelacion = `‚úÖ <b>¬°Has abandonado la sala exitosamente!</b>

üéÆ <b>Sala:</b> ${sala.nombre || sala._id}
‚ö†Ô∏è <b>La sala ha sido cancelada</b> porque qued√≥ sin jugadores.`;

      // Agregar informaci√≥n del reembolso del backend
      if (reembolsoInfo && reembolsoInfo.procesado) {
        mensajeCancelacion += `

üí∞ <b>Reembolso procesado autom√°ticamente:</b>
‚Ä¢ <b>Monto devuelto:</b> ${(reembolsoInfo.monto / 100).toLocaleString(
          "es-VE"
        )} Bs
‚Ä¢ <b>Saldo actual:</b> ${(reembolsoInfo.saldoNuevo / 100).toLocaleString(
          "es-VE"
        )} Bs
`;
      } else if (reembolsoInfo && !reembolsoInfo.procesado) {
        mensajeCancelacion += `

‚ö†Ô∏è <b>Reembolso pendiente:</b>
‚Ä¢ Hubo un problema procesando el reembolso de ${(
          reembolsoInfo.monto / 100
        ).toLocaleString("es-VE")} Bs
‚Ä¢ Contacta al administrador con esta informaci√≥n`;
      }

      mensajeCancelacion += `

üìã <b>Pr√≥ximos pasos:</b>
‚Ä¢ Puedes crear una nueva sala
‚Ä¢ O unirte a otra sala disponible
‚Ä¢ ¬°Gracias por participar!`;

      await bot.sendMessage(chatId, mensajeCancelacion, {
        parse_mode: "HTML",
      });

      // Registrar el abandono VOLUNTARIO en el sistema de l√≠mites
      const resultadoAbandono =
        abandonLimitManager.registerAbandonVoluntario(telegramId);

      // Mostrar informaci√≥n sobre el estado de l√≠mites
      if (resultadoAbandono.mensaje) {
        await bot.sendMessage(chatId, resultadoAbandono.mensaje, {
          parse_mode: "HTML",
        });
      }

      await bot.answerCallbackQuery(callbackQuery.id, {
        text: reembolsoInfo?.procesado
          ? "‚úÖ Sala abandonada, cancelada y reembolsada"
          : "‚úÖ Sala abandonada y cancelada",
      });
    } else {
      let mensajeAbandono = `‚úÖ <b>¬°Has abandonado la sala exitosamente!</b>

üéÆ <b>Sala:</b> ${sala.nombre || sala._id}
üë• <b>Jugadores restantes:</b> ${sala.jugadores?.length || 0}`;

      // Agregar informaci√≥n del reembolso del backend
      if (reembolsoInfo && reembolsoInfo.procesado) {
        mensajeAbandono += `

üí∞ <b>Reembolso procesado autom√°ticamente:</b>
‚Ä¢ <b>Monto devuelto:</b> ${(reembolsoInfo.monto / 100).toLocaleString(
          "es-VE"
        )} Bs
‚Ä¢ <b>Saldo actual:</b> ${(reembolsoInfo.saldoNuevo / 100).toLocaleString(
          "es-VE"
        )} Bs
`;
      } else if (reembolsoInfo && !reembolsoInfo.procesado) {
        mensajeAbandono += `

‚ö†Ô∏è <b>Reembolso pendiente:</b>
‚Ä¢ Hubo un problema procesando el reembolso de ${(
          reembolsoInfo.monto / 100
        ).toLocaleString("es-VE")} Bs
‚Ä¢ Contacta al administrador`;
      }

      mensajeAbandono += `

üìã <b>Pr√≥ximos pasos:</b>
‚Ä¢ Puedes unirte a otra sala
‚Ä¢ O crear una nueva sala
‚Ä¢ ¬°Gracias por participar!`;

      await bot.sendMessage(chatId, mensajeAbandono, {
        parse_mode: "HTML",
      });

      // Notificar a los jugadores restantes sobre el abandono
      if (sala.jugadores && sala.jugadores.length > 0) {
        const {
          notificarJugadorAbandono,
        } = require("../../utils/sala-notifications");
        await notificarJugadorAbandono(bot, api, sala, jugador);
      }

      // Registrar el abandono VOLUNTARIO en el sistema de l√≠mites
      const resultadoAbandono =
        abandonLimitManager.registerAbandonVoluntario(telegramId);

      // Mostrar informaci√≥n sobre el estado de l√≠mites
      if (resultadoAbandono.mensaje) {
        await bot.sendMessage(chatId, resultadoAbandono.mensaje, {
          parse_mode: "HTML",
        });
      }

      await bot.answerCallbackQuery(callbackQuery.id, {
        text: reembolsoInfo?.procesado
          ? "‚úÖ Abandonado la sala y reembolsado"
          : "‚úÖ Abandonado la sala exitosamente",
      });
    }
  } catch (err) {
    console.error("‚ùå Error en leave sala:", err.response?.data || err.message);

    // Manejar errores espec√≠ficos del backend
    const errorData = err.response?.data || err.message;
    if (errorData && typeof errorData === "object" && errorData.mensaje) {
      const mensaje = errorData.mensaje;

      // Errores espec√≠ficos de validaci√≥n
      if (mensaje.includes("No est√°s en esta sala")) {
        await bot.sendMessage(
          chatId,
          `‚ÑπÔ∏è <b>No est√°s en esta sala</b>

No puedes abandonar una sala en la que no est√°s participando.`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, {
          text: "No est√°s en esta sala",
        });
      } else if (mensaje.includes("No puedes abandonar")) {
        await bot.sendMessage(
          chatId,
          `‚ùå <b>No puedes abandonar esta sala</b>

${mensaje}`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, {
          text: "No puedes abandonar",
        });
      } else {
        // Otros errores espec√≠ficos del backend
        await bot.sendMessage(
          chatId,
          `‚ùå <b>Error al abandonar</b>

${mensaje}`,
          { parse_mode: "HTML" }
        );
        await bot.answerCallbackQuery(callbackQuery.id, { text: "‚ùå Error" });
      }
    } else {
      // Error gen√©rico
      await bot.sendMessage(
        chatId,
        "‚ùå Error abandonando la sala. Intenta de nuevo o contacta al admin.",
        { parse_mode: "HTML" }
      );
      await bot.answerCallbackQuery(callbackQuery.id, { text: "‚ùå Error" });
    }
  }
}

/**
 * Maneja la confirmaci√≥n de entrada a una sala
 */
async function handleConfirmEntrada(bot, api, callbackQuery, salaId) {
  const { message, from } = callbackQuery;
  const chatId = message.chat.id;

  try {
    // 1) Buscar o crear jugador en backend (por telegramId)
    const jugador = await registerOrFindPlayer(api, from);

    // 2) Obtener informaci√≥n de la sala
    const salas = await api.getSalasDisponibles();
    const sala = salas.find((s) => s._id === salaId);

    if (!sala) {
      await bot.answerCallbackQuery(callbackQuery.id, {
        text: "‚ùå Sala no encontrada",
      });
      await bot.sendMessage(
        chatId,
        "‚ùå <b>Error:</b> La sala no fue encontrada. Intenta de nuevo.",
        { parse_mode: "HTML" }
      );
      return;
    }

    const precioEntrada = sala.configuracion?.entrada || 0;

    // 3) Verificar saldo nuevamente (por seguridad)
    const saldoJugador = await api.getPlayerBalance(from.id.toString());

    if (saldoJugador < precioEntrada) {
      await bot.answerCallbackQuery(callbackQuery.id, {
        text: "‚ùå Saldo insuficiente",
      });
      await bot.sendMessage(
        chatId,
        "‚ùå <b>Error:</b> Tu saldo ha cambiado y ya no es suficiente para entrar a esta sala.",
        { parse_mode: "HTML" }
      );
      return;
    }

    // 4) Procesar pago usando el nuevo sistema de transacciones
    const resultadoPago = await api.procesarPagoEntrada(
      jugador._id || jugador.id,
      precioEntrada,
      salaId
    );

    if (!resultadoPago.exito) {
      await bot.answerCallbackQuery(callbackQuery.id, {
        text: "‚ùå Error procesando pago",
      });
      await bot.sendMessage(
        chatId,
        `‚ùå <b>Error procesando el pago:</b> ${
          resultadoPago.error || "Error desconocido"
        }`,
        { parse_mode: "HTML" }
      );
      return;
    }

    // 5) Unir al jugador a la sala
    const joinRes = await api.joinSala(salaId, jugador._id || jugador.id);
    const salaActualizada = joinRes.sala || joinRes;

    // 6) Responder al jugador con informaci√≥n de la transacci√≥n
    const saldoRestante =
      resultadoPago.saldoNuevo || saldoJugador - precioEntrada;

    await bot.sendMessage(
      chatId,
      `‚úÖ <b>¬°Te has unido a la sala exitosamente!</b>

üéÆ <b>Sala:</b> ${sala.nombre || sala._id}
üí∞ <b>Entrada pagada:</b> ${(precioEntrada / 100).toLocaleString("es-VE")} Bs
üí≥ <b>Saldo restante:</b> ${(saldoRestante / 100).toLocaleString("es-VE")} Bs
üë• <b>Jugadores:</b> ${salaActualizada.jugadores?.length || 0}

üìã <b>Pr√≥ximos pasos:</b>
‚Ä¢ Espera a que se complete la sala
‚Ä¢ ¬°Disfruta tu partida!`,
      { parse_mode: "HTML" }
    );

    // 7) Notificar a todos los jugadores de la sala sobre el nuevo jugador
    console.log(
      "üîç [JOINSALA] Antes de notificar - salaActualizada:",
      JSON.stringify(salaActualizada, null, 2)
    );
    console.log(
      "üîç [JOINSALA] Antes de notificar - jugador:",
      JSON.stringify(jugador, null, 2)
    );

    const { notificarNuevoJugador } = require("../../utils/sala-notifications");
    await notificarNuevoJugador(bot, api, salaActualizada, jugador);

    // 8) Verificar si la sala est√° completa y notificar
    console.log("üîç [JOINSALA] Verificando si la sala est√° completa...");
    console.log(
      "üîç [JOINSALA] salaActualizada.jugadores:",
      salaActualizada.jugadores
    );
    console.log(
      "üîç [JOINSALA] Cantidad de jugadores:",
      salaActualizada.jugadores?.length
    );
    console.log(
      "üîç [JOINSALA] salaActualizada.configuracion:",
      salaActualizada.configuracion
    );
    console.log(
      "üîç [JOINSALA] maxJugadores:",
      salaActualizada.configuracion?.maxJugadores
    );
    console.log(
      "üîç [JOINSALA] maxJugadores (fallback):",
      salaActualizada.configuracion?.maxJugadores || 999
    );

    // Obtener maxJugadores del modo de la sala
    const modo = salaActualizada.modo;
    let maxJugadores = salaActualizada.configuracion?.maxJugadores;

    console.log("üîç [JOINSALA] salaActualizada.modo:", salaActualizada.modo);
    console.log(
      "üîç [JOINSALA] salaActualizada.estado:",
      salaActualizada.estado
    );

    // Si no est√° en configuraci√≥n, obtener del modo
    if (!maxJugadores && modo) {
      const juego = BOT_CONFIG.juegos.find(
        (j) => j.id === salaActualizada.juego
      );
      if (juego && juego.modos && juego.modos[modo]) {
        maxJugadores = juego.modos[modo].maxJugadores;
        console.log(
          "üîç [JOINSALA] maxJugadores obtenido del modo:",
          maxJugadores
        );
      }
    }

    // Fallback final
    if (!maxJugadores) {
      maxJugadores = 999;
      console.log("üîç [JOINSALA] maxJugadores usando fallback:", maxJugadores);
    }

    const jugadoresActuales = salaActualizada.jugadores?.length || 0;
    const salaCompleta = jugadoresActuales >= maxJugadores;

    // Tambi√©n verificar si el backend ya marc√≥ la sala como completa
    const salaMarcadaCompleta = salaActualizada.estado === "completa";

    console.log("üîç [JOINSALA] Condici√≥n de sala completa:");
    console.log("üîç [JOINSALA] - jugadoresActuales:", jugadoresActuales);
    console.log("üîç [JOINSALA] - maxJugadores:", maxJugadores);
    console.log(
      "üîç [JOINSALA] - jugadoresActuales >= maxJugadores:",
      salaCompleta
    );
    console.log(
      "üîç [JOINSALA] - sala marcada como completa por backend:",
      salaMarcadaCompleta
    );

    if (salaCompleta || salaMarcadaCompleta) {
      console.log(
        "üéØ [JOINSALA] ¬°SALA COMPLETA! Llamando a notificarSalaCompleta..."
      );
      const {
        notificarSalaCompleta,
      } = require("../../utils/sala-notifications");
      await notificarSalaCompleta(bot, api, salaActualizada);
      console.log("‚úÖ [JOINSALA] notificarSalaCompleta completada");
    } else {
      console.log(
        "‚è≥ [JOINSALA] Sala no est√° completa a√∫n, no se env√≠a notificaci√≥n"
      );
    }

    // Acknowledge callback
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "‚úÖ Unido a la sala exitosamente",
    });
  } catch (err) {
    console.error(
      "‚ùå Error en confirmaci√≥n de entrada:",
      err.response?.data || err.message
    );

    // Manejar errores espec√≠ficos del backend
    const errorData = err.response?.data || err.message;
    if (errorData && typeof errorData === "object" && errorData.mensaje) {
      const mensaje = errorData.mensaje;

      if (mensaje.includes("Saldo insuficiente")) {
        await bot.sendMessage(
          chatId,
          "‚ùå <b>Error:</b> Tu saldo no es suficiente para entrar a esta sala.",
          { parse_mode: "HTML" }
        );
      } else {
        await bot.sendMessage(
          chatId,
          `‚ùå <b>Error al confirmar entrada:</b>

${mensaje}`,
          { parse_mode: "HTML" }
        );
      }
    } else {
      await bot.sendMessage(
        chatId,
        "‚ùå Error confirmando la entrada. Intenta de nuevo o contacta al admin."
      );
    }

    await bot.answerCallbackQuery(callbackQuery.id, { text: "‚ùå Error" });
  }
}

/**
 * Maneja la cancelaci√≥n de entrada a una sala
 */
async function handleCancelarEntrada(bot, api, callbackQuery) {
  const { message, from } = callbackQuery;
  const chatId = message.chat.id;

  try {
    // Acknowledge callback
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "‚ùå Entrada cancelada",
    });

    // Mensaje de cancelaci√≥n
    await bot.sendMessage(
      chatId,
      `‚úÖ <b>Entrada cancelada</b>

Has decidido no unirte a la sala. Puedes intentar de nuevo cuando quieras.`,
      { parse_mode: "HTML" }
    );
  } catch (err) {
    console.error("‚ùå Error cancelando entrada:", err.message);
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "‚ùå Error",
    });
  }
}

/**
 * Maneja el inicio del proceso de dep√≥sito (placeholder)
 */
async function handleDepositoInicio(bot, api, callbackQuery) {
  const { message, from } = callbackQuery;
  const chatId = message.chat.id;

  try {
    // Acknowledge callback
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "üí∞ Procesando dep√≥sito...",
    });

    // Mensaje temporal hasta que se implemente la funcionalidad de dep√≥sito
    await bot.sendMessage(
      chatId,
      `üí∞ <b>Sistema de Dep√≥sitos</b>

‚ö†Ô∏è <b>Funcionalidad en desarrollo</b>

La funcionalidad de dep√≥sitos estar√° disponible pr√≥ximamente.

üìã <b>M√©todos de pago que se implementar√°n:</b>
‚Ä¢ Transferencias bancarias
‚Ä¢ Pagos m√≥viles  
‚Ä¢ Tarjetas de cr√©dito/d√©bito

üí° <b>Por ahora, contacta al administrador para realizar dep√≥sitos.</b>

Gracias por tu paciencia.`,
      { parse_mode: "HTML" }
    );
  } catch (err) {
    console.error("‚ùå Error en inicio de dep√≥sito:", err.message);
    await bot.answerCallbackQuery(callbackQuery.id, {
      text: "‚ùå Error",
    });
  }
}

module.exports = {
  handleCreateSalaMode,
  handleJoinSala,
  handleConfirmLeaveSala,
  handleCancelLeaveSala,
  handleLeaveSala,
  handleConfirmEntrada,
  handleCancelarEntrada,
  handleDepositoInicio,
};
