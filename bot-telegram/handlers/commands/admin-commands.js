"use strict";

const axios = require("axios");
const BOT_CONFIG = require("../../config/bot-config");
const { isAdmin, getCacheStats } = require("../../utils/helpers");
const paymentCommands = require("./admin-payment-commands");
const abandonLimitManager = require("../../utils/abandon-limits");
const { getWebAppUrl } = require("../../config/webapp-config");

// Variables de entorno
const TEST_MODE = process.env.TEST_MODE === "true" || !process.env.BACKEND_URL;

/**
 * Comando /stats - Estad√≠sticas del sistema (solo admin)
 */
async function handleStats(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  try {
    if (!isAdmin(userId)) {
      await bot.sendMessage(
        chatId,
        "‚ùå No tienes permisos para usar este comando.",
        { parse_mode: "HTML" }
      );
      return;
    }

    // Obtener estad√≠sticas del cache
    const cacheStats = getCacheStats();

    // Obtener estad√≠sticas del backend si est√° disponible
    let backendStats = null;
    if (!TEST_MODE && api) {
      try {
        backendStats = await api.getSystemStats();
      } catch (error) {
        console.log(
          "Error obteniendo estad√≠sticas del backend:",
          error.message
        );
      }
    }

    let statsMessage = `üìä <b>Estad√≠sticas del Sistema</b>

üîß <b>Cache:</b>
‚Ä¢ Estrategia: ${cacheStats.strategy || "local"}
‚Ä¢ Usuarios en cache: ${cacheStats.totalUsers || 0}
‚Ä¢ Usuarios activos: ${cacheStats.activeUsers || 0}
‚Ä¢ √öltima limpieza: ${cacheStats.lastCleanup || "N/A"}`;

    if (backendStats) {
      statsMessage += `

üåê <b>Backend:</b>
‚Ä¢ Total usuarios: ${backendStats.totalUsers || 0}
‚Ä¢ Usuarios activos: ${backendStats.activeUsers || 0}
‚Ä¢ Total salas: ${backendStats.totalRooms || 0}
‚Ä¢ Salas activas: ${backendStats.activeRooms || 0}`;
    }

    if (TEST_MODE) {
      statsMessage += `

üß™ <b>Modo:</b> TEST (sin backend)`;
    }

    await bot.sendMessage(chatId, statsMessage, {
      parse_mode: "HTML",
    });
  } catch (err) {
    console.error("‚ùå Error en /stats:", err.message);
    await bot.sendMessage(
      chatId,
      "‚ùå Error obteniendo estad√≠sticas. Intenta de nuevo."
    );
  }
}

/**
 * Comando /token - Verificar estado del token de autenticaci√≥n (solo admin)
 */
async function handleToken(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  try {
    if (!isAdmin(userId)) {
      await bot.sendMessage(
        chatId,
        "‚ùå No tienes permisos para usar este comando.",
        { parse_mode: "HTML" }
      );
      return;
    }

    if (TEST_MODE) {
      await bot.sendMessage(
        chatId,
        "üß™ <b>Modo TEST activo</b>\nNo hay token de autenticaci√≥n en modo TEST.",
        { parse_mode: "HTML" }
      );
      return;
    }

    // Obtener informaci√≥n del token
    const tokenInfo = api.getTokenInfo();

    let tokenMessage = `üîê <b>Estado del Token de Autenticaci√≥n</b>

üìã <b>Informaci√≥n:</b>
‚Ä¢ V√°lido: ${tokenInfo.valid ? "‚úÖ S√≠" : "‚ùå No"}
‚Ä¢ Expira: ${
      tokenInfo.expiresAt ? tokenInfo.expiresAt.toLocaleString("es-ES") : "N/A"
    }`;

    if (tokenInfo.timeUntilExpiry) {
      const minutes = Math.round(tokenInfo.timeUntilExpiry / 60000);
      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;

      tokenMessage += `\n‚Ä¢ Tiempo restante: ${
        hours > 0 ? `${hours}h ${remainingMinutes}m` : `${remainingMinutes}m`
      }`;
    }

    if (tokenInfo.willExpireSoon) {
      tokenMessage += `\n\n‚ö†Ô∏è <b>Advertencia:</b> El token expirar√° pronto`;
    }

    // Agregar botones de acci√≥n
    const keyboard = {
      inline_keyboard: [
        [
          {
            text: "üîÑ Renovar Token",
            callback_data: "refresh_token",
          },
        ],
        [
          {
            text: "üìä Ver Estad√≠sticas",
            callback_data: "view_stats",
          },
        ],
      ],
    };

    await bot.sendMessage(chatId, tokenMessage, {
      parse_mode: "HTML",
      reply_markup: keyboard,
    });
  } catch (err) {
    console.error("‚ùå Error en /token:", err.message);
    await bot.sendMessage(
      chatId,
      "‚ùå Error obteniendo informaci√≥n del token. Intenta de nuevo."
    );
  }
}

/**
 * Comando /setwelcome - Configurar comandos del bot (solo admin)
 */
async function handleSetWelcome(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;
  const adminId = process.env.ADMIN_ID;

  if (!isAdmin(userId)) {
    const errorMessage = `‚ùå <b>No tienes permisos para configurar esto.</b>

üîç <b>Informaci√≥n de debug:</b>
- Tu ID: \`${userId}\`- ADMIN_ID configurado: \`${adminId}\`- Username: @${
      msg.from.username || "N/A"
    }

üí° <b>Para solucionarlo:</b>
1. Ejecuta /myid para obtener tu ID correcto
2. Actualiza ADMIN_ID en tu archivo .env
3. Reinicia el bot`;

    return bot.sendMessage(chatId, errorMessage, { parse_mode: "HTML" });
  }

  try {
    await bot.setMyCommands(BOT_CONFIG.commands);
    await bot.sendMessage(
      chatId,
      "‚úÖ Configuraci√≥n del bot actualizada correctamente."
    );
  } catch (err) {
    console.error("Error configurando bot:", err);
    await bot.sendMessage(chatId, "Error configurando el bot.");
  }
}

/**
 * Comando /setupmeta - Configurar metadatos del bot (solo admin)
 */
async function handleSetupMeta(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (!isAdmin(userId)) {
    return bot.sendMessage(
      chatId,
      "‚ùå Solo el administrador puede ejecutar este comando."
    );
  }

  const token = process.env.BOT_TOKEN;
  const apiUrl = `https://api.telegram.org/bot${token}`;

  // Textos sugeridos
  const shortDescription =
    "Organiza y √∫nete a salas de juegos (Ludo, Domin√≥, Damas). Pulsa Iniciar para comenzar.";
  const description = [
    "Bienvenido a El Patio. Con este bot puedes:",
    "‚Ä¢ Seleccionar un juego",
    "‚Ä¢ Ver salas disponibles",
    "‚Ä¢ Unirte a partidas y gestionar pagos",
    "\nPulsa Iniciar para registrarte y empezar.",
  ].join("\n");

  try {
    // 1) Short description
    await axios.post(`${apiUrl}/setMyShortDescription`, {
      short_description: shortDescription,
      language_code: "es",
    });

    // 2) Description
    await axios.post(`${apiUrl}/setMyDescription`, {
      description,
      language_code: "es",
    });

    // 3) Commands
    await bot.setMyCommands(BOT_CONFIG.commands);

    await bot.sendMessage(
      chatId,
      "‚úÖ Metadatos configurados: descripci√≥n, short description y comandos."
    );
  } catch (err) {
    console.error(
      "Error configurando metadatos:",
      err.response?.data || err.message
    );
    await bot.sendMessage(
      chatId,
      "‚ùå Error configurando metadatos. Revisa el token y vuelve a intentar."
    );
  }
}

/**
 * Comando /cleanup - Limpiar configuraci√≥n del bot (solo admin)
 */
async function handleCleanup(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (!isAdmin(userId)) {
    return bot.sendMessage(
      chatId,
      "‚ùå Solo el administrador puede ejecutar este comando."
    );
  }

  try {
    await bot.setMyCommands([]);
    await bot.sendMessage(
      chatId,
      "‚úÖ Configuraci√≥n del bot limpiada. Los comandos han sido removidos del men√∫."
    );
  } catch (err) {
    console.error("Error limpiando configuraci√≥n:", err);
    await bot.sendMessage(chatId, "‚ùå Error limpiando la configuraci√≥n.");
  }
}

/**
 * Comando /restore - Restaurar configuraci√≥n b√°sica (solo admin)
 */
async function handleRestore(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  if (!isAdmin(userId)) {
    return bot.sendMessage(
      chatId,
      "‚ùå Solo el administrador puede ejecutar este comando."
    );
  }

  try {
    const basicCommands = [
      { command: "start", description: "üöÄ Iniciar el bot" },
      { command: "salas", description: "üéÆ Ver salas disponibles" },
      { command: "ayuda", description: "‚ùì Ver ayuda" },
    ];

    await bot.setMyCommands(basicCommands);
    await bot.sendMessage(
      chatId,
      "‚úÖ Configuraci√≥n b√°sica restaurada. Solo comandos esenciales disponibles."
    );
  } catch (err) {
    console.error("Error restaurando configuraci√≥n:", err);
    await bot.sendMessage(chatId, "‚ùå Error restaurando la configuraci√≥n.");
  }
}

/**
 * Comando /abandonlimits - Ver l√≠mites de abandono de un jugador (solo admin)
 * Uso: /abandonlimits <telegramId>
 */
async function handleAbandonLimits(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  try {
    if (!isAdmin(userId)) {
      await bot.sendMessage(
        chatId,
        "‚ùå No tienes permisos para usar este comando.",
        { parse_mode: "HTML" }
      );
      return;
    }

    // Obtener el telegramId del mensaje
    const args = msg.text.split(" ");
    if (args.length < 2) {
      await bot.sendMessage(
        chatId,
        `üìã <b>Uso del comando:</b>\n\n<code>/abandonlimits &lt;telegramId&gt;</code>\n\nüí° <b>Ejemplo:</b>\n<code>/abandonlimits 123456789</code>`,
        { parse_mode: "HTML" }
      );
      return;
    }

    const telegramId = args[1];

    // Convertir telegramId a n√∫mero para que coincida con el tipo usado en la cache
    const telegramIdNumber = parseInt(telegramId);

    // Obtener estad√≠sticas del jugador
    console.log(
      `üîç [ABANDONLIMITS] Consultando estad√≠sticas para usuario: ${telegramId} (convertido a n√∫mero: ${telegramIdNumber})`
    );
    console.log(
      `üìä [ABANDONLIMITS] Cache del abandonLimitManager:`,
      abandonLimitManager.cache.size,
      "usuarios"
    );

    const stats = abandonLimitManager.getPlayerStats(telegramIdNumber);
    console.log(`üìä [ABANDONLIMITS] Resultado de getPlayerStats:`, stats);

    if (!stats) {
      console.log(`‚ùå [ABANDONLIMITS] Usuario ${telegramId} sin historial`);
      await bot.sendMessage(
        chatId,
        `‚ÑπÔ∏è <b>Jugador sin historial</b>\n\nEl jugador <code>${telegramId}</code> no tiene historial de abandonos registrado.`,
        { parse_mode: "HTML" }
      );
      return;
    }

    // Construir mensaje de estad√≠sticas
    let mensaje = `üìä <b>L√≠mites de Abandono - Jugador ${telegramId}</b>\n\n`;

    mensaje += `‚è∞ <b>√öltima hora:</b> ${stats.abandonosHora}/${stats.infoAdicional.limiteHora}\n`;
    mensaje += `üìÖ <b>Hoy:</b> ${stats.abandonosDia}/${stats.infoAdicional.limiteDia}\n\n`;

    if (stats.bloqueado) {
      mensaje += `üö´ <b>Estado:</b> BLOQUEADO para abandonar\n`;
      mensaje += `‚è∞ <b>Tiempo restante:</b> ${stats.tiempoRestante} minutos\n\n`;
    } else {
      mensaje += `‚úÖ <b>Estado:</b> Puede abandonar normalmente\n`;
      mensaje += `üîÑ <b>Abandonos restantes:</b> ${stats.infoAdicional.abandonosRestantesHora} por hora, ${stats.infoAdicional.abandonosRestantesDia} por d√≠a\n\n`;
    }

    mensaje += `üí° <b>Informaci√≥n del Sistema:</b>\n`;
    mensaje += `‚Ä¢ Solo cuentan los abandonos VOLUNTARIOS del jugador\n`;
    mensaje += `‚Ä¢ NO cuentan las cancelaciones autom√°ticas de salas\n`;
    mensaje += `‚Ä¢ Los contadores se resetean autom√°ticamente por tiempo`;

    await bot.sendMessage(chatId, mensaje, {
      parse_mode: "HTML",
    });
  } catch (err) {
    console.error("‚ùå Error en /abandonlimits:", err.message);
    await bot.sendMessage(
      chatId,
      "‚ùå Error obteniendo l√≠mites de abandono. Intenta de nuevo."
    );
  }
}

/**
 * Comando /abandonsystem - Ver estad√≠sticas del sistema de l√≠mites (solo admin)
 */
async function handleAbandonSystem(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  try {
    if (!isAdmin(userId)) {
      await bot.sendMessage(
        chatId,
        "‚ùå No tienes permisos para usar este comando.",
        { parse_mode: "HTML" }
      );
      return;
    }

    // Obtener estad√≠sticas del sistema
    console.log(`üîç [ABANDONSYSTEM] Consultando estad√≠sticas del sistema`);
    console.log(
      `üìä [ABANDONSYSTEM] Cache del abandonLimitManager:`,
      abandonLimitManager.cache.size,
      "usuarios"
    );

    const systemStats = abandonLimitManager.getSystemStats();
    console.log(`üìä [ABANDONSYSTEM] Resultado de getSystemStats:`, systemStats);

    // Construir mensaje de estad√≠sticas del sistema
    let mensaje = `üìä <b>Estad√≠sticas del Sistema de L√≠mites de Abandono</b>\n\n`;

    mensaje += `üë• <b>Usuarios:</b>\n`;
    mensaje += `‚Ä¢ Total en sistema: ${systemStats.totalUsuarios}\n`;
    mensaje += `‚Ä¢ Bloqueados actualmente: ${systemStats.usuariosBloqueados}\n\n`;

    mensaje += `üìà <b>Actividad:</b>\n`;
    mensaje += `‚Ä¢ Total abandonos por hora: ${systemStats.totalAbandonosHora}\n`;
    mensaje += `‚Ä¢ Total abandonos por d√≠a: ${systemStats.totalAbandonosDia}\n\n`;

    mensaje += `‚öôÔ∏è <b>Configuraci√≥n:</b>\n`;
    mensaje += `‚Ä¢ L√≠mite por hora: ${systemStats.limites.maxAbandonosPorHora} abandonos\n`;
    mensaje += `‚Ä¢ L√≠mite por d√≠a: ${systemStats.limites.maxAbandonosPorDia} abandonos\n\n`;

    mensaje += `üí° <b>Nota:</b> Solo se cuentan los abandonos VOLUNTARIOS de los jugadores.\n`;
    mensaje += `Las cancelaciones autom√°ticas de salas NO afectan estos l√≠mites.`;

    await bot.sendMessage(chatId, mensaje, {
      parse_mode: "HTML",
    });
  } catch (err) {
    console.error("‚ùå Error en /abandonsystem:", err.message);
    await bot.sendMessage(
      chatId,
      "‚ùå Error obteniendo estad√≠sticas del sistema. Intenta de nuevo."
    );
  }
}

/**
 * Comando /checkabandons - Verificar estado del conteo de abandonos de un jugador (solo admin)
 * Uso: /checkabandons <telegramId>
 */
async function handleCheckAbandons(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  try {
    if (!isAdmin(userId)) {
      await bot.sendMessage(
        chatId,
        "‚ùå No tienes permisos para usar este comando.",
        { parse_mode: "HTML" }
      );
      return;
    }

    // Obtener el telegramId del mensaje
    const args = msg.text.split(" ");
    if (args.length < 2) {
      await bot.sendMessage(
        chatId,
        `üìã <b>Uso del comando:</b>\n\n<code>/checkabandons &lt;telegramId&gt;</code>\n\nüí° <b>Ejemplo:</b>\n<code>/checkabandons 123456789</code>\n\nüîç <b>Funci√≥n:</b> Este comando muestra el estado actual de los contadores de abandonos del jugador.`,
        { parse_mode: "HTML" }
      );
      return;
    }

    const telegramId = args[1];

    // Convertir telegramId a n√∫mero para que coincida con el tipo usado en la cache
    const telegramIdNumber = parseInt(telegramId);

    // Verificar que el jugador existe en el sistema
    console.log(
      `üîç [CHECKABANDONS] Consultando estad√≠sticas para usuario: ${telegramId} (convertido a n√∫mero: ${telegramIdNumber})`
    );
    console.log(
      `üìä [CHECKABANDONS] Cache del abandonLimitManager:`,
      abandonLimitManager.cache.size,
      "usuarios"
    );

    const stats = abandonLimitManager.getPlayerStats(telegramIdNumber);
    console.log(`üìä [CHECKABANDONS] Resultado de getPlayerStats:`, stats);

    if (!stats) {
      console.log(`‚ùå [CHECKABANDONS] Usuario ${telegramId} sin historial`);
      await bot.sendMessage(
        chatId,
        `‚ÑπÔ∏è <b>Jugador sin historial</b>\n\nEl jugador <code>${telegramId}</code> no tiene historial de abandonos registrado.\n\n‚úÖ <b>Estado:</b> Libre para abandonar salas`,
        { parse_mode: "HTML" }
      );
      return;
    }

    // Mostrar estado actual del jugador
    let mensajeEstado = `üìä <b>Estado de Abandonos del Jugador</b>\n\n`;
    mensajeEstado += `üë§ <b>ID de Telegram:</b> <code>${telegramId}</code>\n\n`;

    // Informaci√≥n del jugador desde el backend si est√° disponible
    if (!TEST_MODE && api) {
      try {
        const jugador = await api.findPlayerByTelegram(telegramIdNumber);
        if (jugador) {
          mensajeEstado += `üë§ <b>Nombre:</b> ${
            jugador.nickname || jugador.displayName || "Sin nombre"
          }\n`;
          mensajeEstado += `üìß <b>Email:</b> ${
            jugador.email || "No registrado"
          }\n\n`;
        }
      } catch (error) {
        console.log("Error obteniendo informaci√≥n del jugador:", error.message);
      }
    }

    mensajeEstado += `üìä <b>Contadores de Abandonos:</b>\n`;
    mensajeEstado += `‚Ä¢ üïê <b>Por hora:</b> ${stats.abandonosHora}/3\n`;
    mensajeEstado += `‚Ä¢ üìÖ <b>Por d√≠a:</b> ${stats.abandonosDia}/8\n\n`;

    mensajeEstado += `üîí <b>Estado del Sistema:</b>\n`;
    if (stats.bloqueado) {
      mensajeEstado += `‚Ä¢ Estado: üö´ <b>BLOQUEADO</b>\n`;
      mensajeEstado += `‚Ä¢ ‚è∞ <b>Tiempo restante:</b> ${stats.tiempoRestante} minutos\n`;
      mensajeEstado += `‚Ä¢ üö® <b>Raz√≥n:</b> L√≠mite de abandonos excedido\n\n`;

      // Calcular tiempo de desbloqueo
      const minutosRestantes = stats.tiempoRestante;
      const horas = Math.floor(minutosRestantes / 60);
      const minutos = minutosRestantes % 60;

      if (horas > 0) {
        mensajeEstado += `‚è≥ <b>Desbloqueo en:</b> ${horas}h ${minutos}m\n\n`;
      } else {
        mensajeEstado += `‚è≥ <b>Desbloqueo en:</b> ${minutos}m\n\n`;
      }
    } else {
      mensajeEstado += `‚Ä¢ Estado: ‚úÖ <b>LIBRE</b>\n`;
      mensajeEstado += `‚Ä¢ üéØ <b>Puede abandonar:</b> ${
        3 - stats.abandonosHora
      } veces m√°s en la pr√≥xima hora\n`;
      mensajeEstado += `‚Ä¢ üéØ <b>Puede abandonar:</b> ${
        8 - stats.abandonosDia
      } veces m√°s hoy\n\n`;
    }

    // Informaci√≥n adicional del sistema
    mensajeEstado += `‚ÑπÔ∏è <b>Informaci√≥n del Sistema:</b>\n`;
    mensajeEstado += `‚Ä¢ L√≠mite por hora: 3 abandonos\n`;
    mensajeEstado += `‚Ä¢ L√≠mite por d√≠a: 8 abandonos\n`;
    mensajeEstado += `‚Ä¢ Duraci√≥n del bloqueo: 1 hora\n`;
    mensajeEstado += `‚Ä¢ Sistema: ${
      TEST_MODE ? "üß™ Modo de prueba" : "üåê Conectado al backend"
    }`;

    await bot.sendMessage(chatId, mensajeEstado, {
      parse_mode: "HTML",
    });
  } catch (err) {
    console.error("‚ùå Error en /checkabandons:", err.message);
    await bot.sendMessage(
      chatId,
      "‚ùå Error obteniendo el estado de abandonos. Intenta de nuevo."
    );
  }
}

/**
 * Comando /debug-webapp - Verificar configuraci√≥n de Mini Apps (solo admin)
 */
async function handleDebugWebapp(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  try {
    if (!isAdmin(userId)) {
      await bot.sendMessage(
        chatId,
        "‚ùå No tienes permisos para usar este comando.",
        { parse_mode: "HTML" }
      );
      return;
    }

    // Obtener URLs de las Mini Apps
    const depositoUrl = getWebAppUrl("DEPOSITO");
    const retiroUrl = getWebAppUrl("RETIRO");
    const salasUrl = getWebAppUrl("SALAS");
    const configUrl = getWebAppUrl("CONFIG");

    await bot.sendMessage(
      chatId,
      `üîß <b>Debug - Configuraci√≥n Mini Apps</b>

üì± <b>URLs de las Mini Apps:</b>
‚Ä¢ üí≥ <b>Dep√≥sito:</b> <code>${depositoUrl}</code>
‚Ä¢ üí∏ <b>Retiro:</b> <code>${retiroUrl}</code>
‚Ä¢ üéÆ <b>Salas:</b> <code>${salasUrl}</code>
‚Ä¢ ‚öôÔ∏è <b>Configuraci√≥n:</b> <code>${configUrl}</code>

üåê <b>Entorno:</b> <code>${process.env.NODE_ENV || "development"}</code>
‚è∞ <b>Timestamp:</b> <code>${new Date().toISOString()}</code>

üí° <b>Para probar:</b> Ve a Perfil ‚Üí Hacer dep√≥sito`,
      { parse_mode: "HTML" }
    );
  } catch (error) {
    await bot.sendMessage(
      chatId,
      `‚ùå <b>Error en configuraci√≥n:</b> <code>${error.message}</code>`,
      { parse_mode: "HTML" }
    );
  }
}

/**
 * Comando /resetabandons - Resetear contadores de abandonos de un jugador (solo admin)
 * Uso: /resetabandons <telegramId>
 */
async function handleResetAbandons(bot, api, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from.id;

  try {
    if (!isAdmin(userId)) {
      await bot.sendMessage(
        chatId,
        "‚ùå No tienes permisos para usar este comando.",
        { parse_mode: "HTML" }
      );
      return;
    }

    // Obtener el telegramId del mensaje
    const args = msg.text.split(" ");
    if (args.length < 2) {
      await bot.sendMessage(
        chatId,
        `üìã <b>Uso del comando:</b>\n\n<code>/resetabandons &lt;telegramId&gt;</code>\n\nüí° <b>Ejemplo:</b>\n<code>/resetabandons 123456789</code>\n\n‚ö†Ô∏è <b>Advertencia:</b> Este comando resetear√° TODOS los contadores de abandonos del jugador.`,
        { parse_mode: "HTML" }
      );
      return;
    }

    const telegramId = args[1];

    // Convertir telegramId a n√∫mero para que coincida con el tipo usado en la cache
    const telegramIdNumber = parseInt(telegramId);

    // Verificar que el jugador existe en el sistema
    console.log(
      `üîç [RESETABANDONS] Consultando estad√≠sticas para usuario: ${telegramId} (convertido a n√∫mero: ${telegramIdNumber})`
    );
    console.log(
      `üìä [RESETABANDONS] Cache del abandonLimitManager:`,
      abandonLimitManager.cache.size,
      "usuarios"
    );

    const statsAntes = abandonLimitManager.getPlayerStats(telegramIdNumber);
    console.log(`üìä [RESETABANDONS] Resultado de getPlayerStats:`, statsAntes);

    if (!statsAntes) {
      console.log(`‚ùå [RESETABANDONS] Usuario ${telegramId} sin historial`);
      await bot.sendMessage(
        chatId,
        `‚ÑπÔ∏è <b>Jugador sin historial</b>\n\nEl jugador <code>${telegramId}</code> no tiene historial de abandonos registrado.\n\nNo es necesario resetear contadores.`,
        { parse_mode: "HTML" }
      );
      return;
    }

    // Mostrar estado actual antes del reset
    let mensajeConfirmacion = `üîÑ <b>Confirmaci√≥n de Reset de Contadores</b>\n\n`;
    mensajeConfirmacion += `üë§ <b>Jugador:</b> <code>${telegramId}</code>\n\n`;
    mensajeConfirmacion += `üìä <b>Estado actual:</b>\n`;
    mensajeConfirmacion += `‚Ä¢ Abandonos por hora: ${statsAntes.abandonosHora}/3\n`;
    mensajeConfirmacion += `‚Ä¢ Abandonos por d√≠a: ${statsAntes.abandonosDia}/8\n`;
    mensajeConfirmacion += `‚Ä¢ Estado: ${
      statsAntes.bloqueado ? "üö´ BLOQUEADO" : "‚úÖ LIBRE"
    }\n\n`;

    if (statsAntes.bloqueado) {
      mensajeConfirmacion += `‚è∞ <b>Tiempo restante hasta desbloqueo:</b> ${statsAntes.tiempoRestante} minutos\n\n`;
    }

    mensajeConfirmacion += `‚ö†Ô∏è <b>¬øEst√°s seguro de que quieres resetear TODOS los contadores?</b>\n\n`;
    mensajeConfirmacion += `üí° <b>Despu√©s del reset:</b>\n`;
    mensajeConfirmacion += `‚Ä¢ El jugador podr√° abandonar salas normalmente\n`;
    mensajeConfirmacion += `‚Ä¢ Todos los contadores se reiniciar√°n a 0\n`;
    mensajeConfirmacion += `‚Ä¢ El bloqueo se eliminar√° inmediatamente`;

    // Crear teclado de confirmaci√≥n
    const keyboard = {
      inline_keyboard: [
        [
          {
            text: "‚úÖ S√≠, Resetear Contadores",
            callback_data: `reset_abandons:${telegramIdNumber}`,
          },
        ],
        [
          {
            text: "‚ùå Cancelar",
            callback_data: "cancel_reset_abandons",
          },
        ],
      ],
    };

    await bot.sendMessage(chatId, mensajeConfirmacion, {
      parse_mode: "HTML",
      reply_markup: keyboard,
    });
  } catch (err) {
    console.error("‚ùå Error en /resetabandons:", err.message);
    await bot.sendMessage(
      chatId,
      "‚ùå Error procesando el comando. Intenta de nuevo."
    );
  }
}

module.exports = {
  handleStats,
  handleToken,
  handleSetWelcome,
  handleSetupMeta,
  handleCleanup,
  handleRestore,
  handleAbandonLimits,
  handleAbandonSystem,
  handleCheckAbandons,
  handleResetAbandons,
  handleDebugWebapp,
  // Comandos de consulta de configuraci√≥n de precios
  handleVerPrecios: paymentCommands.handleVerPrecios,
  handleVerHistorial: paymentCommands.handleVerHistorial,
  handleVerCacheStats: paymentCommands.handleVerCacheStats,
  handleLimpiarCache: paymentCommands.handleLimpiarCache,
  handleAyudaPrecios: paymentCommands.handleAyudaPrecios,
};
